// Appwrite implementation of the database helper
const getAppwrite = () => window.appwrite || {};

window.dbInit = async () => {
    if (window.location.protocol === 'file:') {
        const msg = "âš ï¸ Ù…ØªØµÙØ­Ùƒ ÙŠÙ…Ù†Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù€ Appwrite Ø¹Ù†Ø¯ ÙØªØ­ Ø§Ù„Ù…Ù„Ù Ù…Ø¨Ø§Ø´Ø±Ø© (file://).\n\nÙŠØ±Ø¬Ù‰ ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Live Server Ø£Ùˆ Ø±ÙØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª Ø¹Ù„Ù‰ Ø§Ø³ØªØ¶Ø§ÙØ©ØŒ Ø£Ùˆ Ø¥Ø¶Ø§ÙØ© 'null' ÙƒÙ€ Platform ÙÙŠ Ù„ÙˆØ­Ø© Appwrite.";
        console.warn(msg);
        // We only alert once per session
        if (!sessionStorage.getItem('cors_warned')) {
            alert(msg);
            sessionStorage.setItem('cors_warned', 'true');
        }
    }
    return true;
};

// --- MATERIALS FUNCTIONS ---
window.dbAdd = async (item) => {
    const { databases, storage, DB_ID, COLLECTIONS, BUCKET_ID, ID } = getAppwrite();
    console.log("ðŸ’¾ dbAdd function (Appwrite) triggered with item:", item);
    try {
        if (!databases) throw new Error("Appwrite not initialized");
        if (item.isBlob && item.url instanceof File) {
            console.log("ðŸ“¤ Detected file upload. Ref:", item.id);
            const file = item.url;

            console.log(`â³ Uploading to Appwrite storage (Bucket: ${BUCKET_ID})...`);
            // Capture the response to get the actual ID generated by the server
            const response = await storage.createFile(BUCKET_ID, ID.unique(), file);
            const actualFileId = response.$id;

            console.log(`âœ… Upload complete. ID: ${actualFileId}`);

            // Use the actual ID for URL generation
            const downloadURL = storage.getFileView(BUCKET_ID, actualFileId).href;

            item.url = downloadURL;
            item.isBlob = false;
            item.storagePath = actualFileId;
        }

        const docId = String(item.id);
        console.log("ðŸ“ Attempting to save to Appwrite Database. Collection:", COLLECTIONS.MATERIALS, "ID:", docId);

        // Ensure dataToSave is a clean object for Appwrite
        const dataToSave = { ...item };
        // If url is still a File (meaning upload failed or was skipped), remove it or convert it
        if (dataToSave.url instanceof File) {
            delete dataToSave.url;
        }

        await databases.createDocument(DB_ID, COLLECTIONS.MATERIALS, docId, dataToSave);

        console.log("âœ… Appwrite save successful!");
        return item;
    } catch (e) {
        console.error("âŒ Appwrite Add Error:", e);
        let errorMsg = e.message || "Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ";
        const errorCode = e.code || "";

        if (errorCode === 401 || errorCode === 403) {
            errorMsg = "Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª (Permissions). ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù€ Permissions ÙÙŠ Appwrite Ù„Ù€ Any (create/read).";
        } else if (errorMsg.includes("Attribute not found")) {
            errorMsg = "Ø§Ù„Ù…ØªØµÙØ­ Ù„Ù… ÙŠØ¬Ø¯ Ø¨Ø¹Ø¶ Ø§Ù„Ø­Ù‚ÙˆÙ„ ÙÙŠ Appwrite. ÙŠØ±Ø¬Ù‰ ØªØ´ØºÙŠÙ„ Ù…Ù„Ù fix-appwrite.html Ø£ÙˆÙ„Ø§Ù‹.";
        } else if (errorCode === 400) {
            errorMsg = "Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ§Ù„Ø­Ø© (Schema Mismatch). ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ (Integer/String). " + errorMsg;
        }

        alert("Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­ÙØ¸ (Code " + errorCode + "): " + errorMsg);
        throw e;
    }
};

window.dbGetAll = async () => {
    const { databases, DB_ID, COLLECTIONS } = getAppwrite();
    try {
        if (!databases) throw new Error("Appwrite not initialized");
        const response = await databases.listDocuments(DB_ID, COLLECTIONS.MATERIALS);
        return response.documents;
    } catch (e) {
        console.error("Appwrite dbGetAll Error:", e);
        return [];
    }
};

window.dbDelete = async (id) => {
    const { databases, storage, DB_ID, COLLECTIONS, BUCKET_ID } = getAppwrite();
    const docId = String(id);
    try {
        if (!databases) throw new Error("Appwrite not initialized");
        const doc = await databases.getDocument(DB_ID, COLLECTIONS.MATERIALS, docId);

        // Only try to delete from storage if storagePath is valid (not "unique()" or empty)
        if (doc.storagePath && doc.storagePath !== "unique()" && !doc.storagePath.includes("unique()")) {
            try {
                await storage.deleteFile(BUCKET_ID, doc.storagePath);
                console.log("âœ… File deleted from storage:", doc.storagePath);
            } catch (storageErr) {
                console.warn("âš ï¸ Could not delete file from storage (might not exist):", storageErr);
                // Continue with database deletion even if storage deletion fails
            }
        } else {
            console.log("â­ï¸ Skipping storage deletion (invalid or missing storagePath)");
        }

        await databases.deleteDocument(DB_ID, COLLECTIONS.MATERIALS, docId);
        console.log("âœ… Document deleted from database");
    } catch (e) {
        console.error("âŒ Delete error:", e);
        alert("Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­Ø°Ù: " + (e.message || "Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ"));
        throw e;
    }
};

// --- USERS FUNCTIONS ---
window.dbUserLogin = async (username, password) => {
    const { databases, DB_ID, COLLECTIONS, Query } = getAppwrite();
    try {
        if (!databases) throw new Error("Appwrite not initialized");
        const response = await databases.listDocuments(DB_ID, COLLECTIONS.USERS, [
            Query.equal("username", username)
        ]);

        if (response.total === 0) return null;

        const user = response.documents[0];
        if (user.password === password) {
            // Map Appwrite attributes to match expectations if needed
            return {
                ...user,
                id: user.id || parseInt(user.$id) || user.$id // Fallback for ID handling
            };
        }
        return null;
    } catch (e) {
        console.error("Login Error:", e);
        return null;
    }
};

window.dbUserGetAll = async () => {
    const { databases, DB_ID, COLLECTIONS } = getAppwrite();
    try {
        if (!databases) throw new Error("Appwrite not initialized");
        const response = await databases.listDocuments(DB_ID, COLLECTIONS.USERS);
        return response.documents;
    } catch (e) {
        console.error("User GetAll Error:", e);
        return [];
    }
};

window.dbUserAdd = async (user) => {
    const { databases, DB_ID, COLLECTIONS, Query } = getAppwrite();
    try {
        if (!databases) throw new Error("Appwrite not initialized");
        const check = await databases.listDocuments(DB_ID, COLLECTIONS.USERS, [
            Query.equal("username", user.username)
        ]);
        if (check.total > 0) {
            throw new Error("Username already exists");
        }

        const docId = String(user.id);
        let email = user.email || "";

        // Robust Auto-fix: Ensure email is a valid format and only ASCII for Appwrite
        const isEmailValid = (em) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(em) && /^[\x00-\x7F]*$/.test(em);

        if (!isEmailValid(email)) {
            const safeUsername = (user.username || "student").replace(/[^\x00-\x7F]/g, "") || user.id || "user" + Math.floor(Math.random() * 1000);
            email = `${safeUsername}@batucenter.com`;
            console.log(`ðŸ§¹ Auto-formatting invalid email to: ${email}`);
        }

        const data = {
            id: user.id,
            firstName: user.firstName || "",
            lastName: user.lastName || "",
            email: email,
            username: user.username,
            password: user.password,
            passwordHash: user.password, // Schema requires this
            createdAt: user.createdAt || new Date().toISOString(),
            creationDate: user.createdAt || new Date().toISOString(), // Schema requires this
            isSuspended: user.isSuspended || false,
            isActive: true, // Schema requires this
            deviceId: user.deviceId || null,
            avatar: user.avatar || null
        };
        await databases.createDocument(DB_ID, COLLECTIONS.USERS, docId, data);
        return user;
    } catch (e) {
        console.error("User Add Error:", e);
        let errorMsg = e.message || "Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ";
        const errorCode = e.code || "";
        if (errorCode === 409) errorMsg = "Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„!";
        else if (errorCode === 401 || errorCode === 403) errorMsg = "Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„Ø£Ø°ÙˆÙ†Ø§Øª (Permissions) Ù„ÙƒÙˆÙ„ÙŠÙƒØ´Ù† Users.";

        alert("Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³ØªØ®Ø¯Ù… (Code " + errorCode + "): " + errorMsg);
        throw e;
    }
};

window.dbUserUpdate = async (user) => {
    const { databases, DB_ID, COLLECTIONS } = getAppwrite();
    try {
        if (!databases) throw new Error("Appwrite not initialized");
        const docId = String(user.id || user.$id);
        // Exclude Appwrite system keys from update payload
        const { $id, $createdAt, $updatedAt, $permissions, $databaseId, $collectionId, docId: dId, ...data } = user;

        await databases.updateDocument(DB_ID, COLLECTIONS.USERS, docId, data);
        return user;
    } catch (e) {
        console.error("User Update Error:", e);
        alert("Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ø§Ù„Ø¨: " + (e.message || "Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ") + " (Code: " + (e.code || "None") + ")");
        throw e;
    }
};

window.dbUserDelete = async (id) => {
    const { databases, DB_ID, COLLECTIONS } = getAppwrite();
    const docId = String(id);
    try {
        if (!databases) throw new Error("Appwrite not initialized");
        await databases.deleteDocument(DB_ID, COLLECTIONS.USERS, docId);
    } catch (e) {
        console.error("User Delete Error:", e);
    }
};

// --- LOGS FUNCTIONS ---
window.dbLogAdd = async (log) => {
    const { databases, DB_ID, COLLECTIONS, ID } = getAppwrite();
    try {
        if (!databases) throw new Error("Appwrite not initialized");
        await databases.createDocument(DB_ID, COLLECTIONS.LOGS, ID.unique(), log);
    } catch (e) {
        console.error("Log Add Error:", e);
        // We don't alert for logs to avoid interrupting the user during PrintScreen/etc
        // and because log failure is less critical than material/user creation.
    }
};

window.dbLogGetAll = async () => {
    const { databases, DB_ID, COLLECTIONS } = getAppwrite();
    try {
        if (!databases) throw new Error("Appwrite not initialized");
        const response = await databases.listDocuments(DB_ID, COLLECTIONS.LOGS);
        return response.documents;
    } catch (e) {
        console.error("Log GetAll Error:", e);
        return [];
    }
};

window.dbLogClearAll = async () => {
    const { databases, DB_ID, COLLECTIONS } = getAppwrite();
    try {
        if (!databases) throw new Error("Appwrite not initialized");
        const response = await databases.listDocuments(DB_ID, COLLECTIONS.LOGS);
        for (const doc of response.documents) {
            await databases.deleteDocument(DB_ID, COLLECTIONS.LOGS, doc.$id);
        }
    } catch (e) {
        console.error("Log Clear Error:", e);
    }
};
